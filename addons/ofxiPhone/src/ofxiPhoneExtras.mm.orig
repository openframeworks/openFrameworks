/***********************************************************************
 
 Copyright (c) 2008, 2009, Memo Akten, www.memo.tv
 *** The Mega Super Awesome Visuals Company ***
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of MSA Visuals nor the names of its contributors 
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 *
 * ***********************************************************************/ 


#import "ofxiPhoneExtras.h"

//--------------------------------------------------------------
<<<<<<< HEAD
ofxiPhoneDeviceType iPhoneGetDeviceType() {
=======
ofxiPhoneDeviceType ofxiPhoneGetDeviceType() {
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
	return [[[UIDevice currentDevice] model] caseInsensitiveCompare:@"iPhone"] == NSOrderedSame ? OFXIPHONE_DEVICE_IPHONE : OFXIPHONE_DEVICE_IPODTOUCH;
}


//--------------------------------------------------------------
<<<<<<< HEAD
string iPhoneGetDeviceRevision() {
=======
string ofxiPhoneGetDeviceRevision() {
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
	// ZACH TODO
}

//--------------------------------------------------------------
<<<<<<< HEAD
UIWindow *iPhoneGetUIWindow() {
=======
UIWindow *ofxiPhoneGetUIWindow() {
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
	return [[UIApplication sharedApplication] keyWindow];
}


//--------------------------------------------------------------
<<<<<<< HEAD
EAGLView *iPhoneGetGLView() {
	return [iPhoneGetAppDelegate() getGLView];
=======
EAGLView *ofxiPhoneGetGLView() {
	return [ofxiPhoneGetAppDelegate() getGLView];
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}


//--------------------------------------------------------------
<<<<<<< HEAD
ofAppiPhoneWindow* iPhoneGetOFWindow() {
=======
ofAppiPhoneWindow* ofxiPhoneGetOFWindow() {
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
	return ofAppiPhoneWindow::getInstance();
}


//--------------------------------------------------------------
<<<<<<< HEAD
ofxiPhoneAppDelegate *iPhoneGetAppDelegate() {
=======
ofxiPhoneAppDelegate *ofxiPhoneGetAppDelegate() {
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
	return [[UIApplication sharedApplication] delegate];
}


//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneSendGLViewToFront() {
	[iPhoneGetUIWindow() bringSubviewToFront:iPhoneGetGLView()];
=======
void ofxiPhoneSendGLViewToFront() {
	[ofxiPhoneGetUIWindow() bringSubviewToFront:iPhoneGetGLView()];
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}


//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneSendGLViewToBack() {
	[iPhoneGetUIWindow() sendSubviewToBack:iPhoneGetGLView()];
=======
void ofxiPhoneSendGLViewToBack() {
	[ofxiPhoneGetUIWindow() sendSubviewToBack:iPhoneGetGLView()];
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}


//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneSetGLViewTransparent(bool b) {
	iPhoneGetGLView().opaque = !b;
=======
void ofxiPhoneSetGLViewTransparent(bool b) {
	ofxiPhoneGetGLView().opaque = !b;
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}


//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneSetGLViewUserInteraction(bool b) {
	iPhoneGetGLView().userInteractionEnabled = b;
=======
void ofxiPhoneSetGLViewUserInteraction(bool b) {
	ofxiPhoneGetGLView().userInteractionEnabled = b;
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}



//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneEnableIdleTimer() {
=======
void ofxiPhoneEnableIdleTimer() {
	[UIApplication sharedApplication].idleTimerDisabled = false;
}


//--------------------------------------------------------------
void ofxiPhoneDisableIdleTimer() {
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
	[UIApplication sharedApplication].idleTimerDisabled = true;
}


//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneDisableIdleTimer() {
	[UIApplication sharedApplication].idleTimerDisabled = false;
=======
void ofxiPhoneLockGLContext() {
	[ofxiPhoneGetAppDelegate() lockGL];
}


//--------------------------------------------------------------
void ofxiPhoneUnlockGLContext() {
	[ofxiPhoneGetAppDelegate() unlockGL];
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}


//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneEnableLoopInThread() {
	[iPhoneGetAppDelegate() enableLoopInThread];
=======
void ofxiPhoneEnableLoopInThread() {
	[ofxiPhoneGetAppDelegate() enableLoopInThread];
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}


//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneSetOrientation(UIDeviceOrientation orientation) {
	iPhoneGetOFWindow()->setOrientation(orientation);
=======
void ofxiPhoneSetOrientation(UIDeviceOrientation orientation) {
	ofxiPhoneGetOFWindow()->setOrientation(orientation);
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}


//--------------------------------------------------------------
<<<<<<< HEAD
UIDeviceOrientation iPhoneGetOrientation() {
	return (UIDeviceOrientation)iPhoneGetOFWindow()->getOrientation();;
=======
UIDeviceOrientation ofxiPhoneGetOrientation() {
	return (UIDeviceOrientation)ofxiPhoneGetOFWindow()->getOrientation();
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}


//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneBundleImageToGLTexture(NSString *filename, GLuint *spriteTexture) {
	iPhoneUIImageToGLTexture([UIImage imageNamed:filename], spriteTexture);
=======
bool ofxiPhoneBundleImageToGLTexture(NSString *filename, GLuint *spriteTexture) {
	return ofxiPhoneUIImageToGLTexture([UIImage imageNamed:filename], spriteTexture);
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}


//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneUIImageToGLTexture(UIImage *uiImage, GLuint *spriteTexture) {
	if(!uiImage) return;
=======
bool ofxiPhoneUIImageToGLTexture(UIImage *uiImage, GLuint *spriteTexture) {
	if(!uiImage) return false;
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
	
	CGImageRef cgImage;
	CGContextRef spriteContext;
	GLubyte *pixels;
	size_t	width, height;
	
	// Creates a Core Graphics image from an image file
	cgImage = uiImage.CGImage;
	
	// Get the width and height of the image
	width = CGImageGetWidth(cgImage);
	height = CGImageGetHeight(cgImage);
	
	// Allocated memory needed for the bitmap context
	pixels = (GLubyte *) malloc(width * height * 4);
	// Uses the bitmatp creation function provided by the Core Graphics framework. 
	spriteContext = CGBitmapContextCreate(pixels, width, height, 8, width * 4, CGImageGetColorSpace(cgImage), kCGImageAlphaPremultipliedLast);
	// After you create the context, you can draw the sprite image to the context.
	CGContextDrawImage(spriteContext, CGRectMake(0.0, 0.0, (CGFloat)width, (CGFloat)height), cgImage);
	// You don't need the context at this point, so you need to release it to avoid memory leaks.
	CGContextRelease(spriteContext);
	
	// Use OpenGL ES to generate a name for the texture.
	glGenTextures(1, spriteTexture);
	// Bind the texture name. 
	glBindTexture(GL_TEXTURE_2D, *spriteTexture);
	// Speidfy a 2D texture image, provideing the a pointer to the image data in memory
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
	// Release the image data
	free(pixels);
	
	// Set the texture parameters to use a minifying filter and a linear filer (weighted average)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
<<<<<<< HEAD
=======
	
	return true;
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}


//--------------------------------------------------------------
<<<<<<< HEAD
void iPhoneUIImageToOFImage(UIImage *uiImage, ofImage &outImage) {
	if(!uiImage) return;
	
	CGImageRef cgImage;
	CGContextRef spriteContext;
	GLubyte *pixels;
	size_t	width, height;
	int bpp = 4;
	
	// Creates a Core Graphics image from an image file
	cgImage = uiImage.CGImage;
	
	// Get the width and height of the image
	width = CGImageGetWidth(cgImage);
	height = CGImageGetHeight(cgImage);
	
	
	// Allocated memory needed for the bitmap context
	pixels = (GLubyte *) malloc(width * height * bpp);
	// Uses the bitmatp creation function provided by the Core Graphics framework. 
	spriteContext = CGBitmapContextCreate(pixels, width, height, 8, width * 4, CGImageGetColorSpace(cgImage), kCGImageAlphaPremultipliedLast);
	// After you create the context, you can draw the sprite image to the context.
	CGContextDrawImage(spriteContext, CGRectMake(0.0, 0.0, (CGFloat)width, (CGFloat)height), cgImage);
	// You don't need the context at this point, so you need to release it to avoid memory leaks.
	CGContextRelease(spriteContext);
	
	// vertically flip
	GLubyte *pixelsFlipped = (GLubyte *) malloc(width * height * bpp);
	int numBytesPerRow = width * bpp;
	for(int y=0; y<height; y++) {
		memcpy(pixelsFlipped + (numBytesPerRow * y), pixels + (numBytesPerRow * (height - 1 - y)), numBytesPerRow);
	}
	
	
	outImage.setFromPixels(pixelsFlipped, width, height, OF_IMAGE_COLOR_ALPHA, true);
	
	free(pixels);
	free(pixelsFlipped);
=======
bool ofxiPhoneUIImageToOFImage(UIImage *uiImage, ofImage &outImage, int targetWidth, int targetHeight) {
	if(!uiImage) return false;
	
	CGContextRef spriteContext;
	CGImageRef	cgImage = uiImage.CGImage;

	int bytesPerPixel	= CGImageGetBitsPerPixel(cgImage)/8;
	if(bytesPerPixel == 3) bytesPerPixel = 4;
	
	int width			= targetWidth > 0 ? targetWidth : CGImageGetWidth(cgImage);
	int height			= targetHeight > 0 ? targetHeight : CGImageGetHeight(cgImage);
	
	// Allocated memory needed for the bitmap context
	GLubyte *pixels		= (GLubyte *) malloc(width * height * bytesPerPixel);
	
	// Uses the bitmatp creation function provided by the Core Graphics framework. 
	ofLog(OF_LOG_VERBOSE, "about to CGBitmapContextCreate");
	spriteContext = CGBitmapContextCreate(pixels, width, height, CGImageGetBitsPerComponent(cgImage), width * bytesPerPixel, CGImageGetColorSpace(cgImage), bytesPerPixel == 4 ? kCGImageAlphaPremultipliedLast : kCGImageAlphaNone);
	
	if(spriteContext == NULL) {
		ofLog(OF_LOG_ERROR, "iPhoneUIImageToOFImage - CGBitmapContextCreate returned NULL");
		free(pixels);
		return false;
	}

	// After you create the context, you can draw the sprite image to the context.
	ofLog(OF_LOG_VERBOSE, "about to CGContextDrawImage");
	CGContextDrawImage(spriteContext, CGRectMake(0.0, 0.0, (CGFloat)width, (CGFloat)height), cgImage);
	
	// You don't need the context at this point, so you need to release it to avoid memory leaks.
	ofLog(OF_LOG_VERBOSE, "about to CGContextRelease");
	CGContextRelease(spriteContext);
	
	// vertically flip
//	GLubyte *pixelsFlipped = (GLubyte *) malloc(width * height * bytesPerPixel);
//	int numBytesPerRow = width * bytesPerPixel;
//	for(int y=0; y<height; y++) {
//		memcpy(pixelsFlipped + (numBytesPerRow * y), pixels + (numBytesPerRow * (height - 1 - y)), numBytesPerRow);
//	}
//	outImage.setFromPixels(pixelsFlipped, width, height, OF_IMAGE_COLOR_ALPHA, true);
//	free(pixelsFlipped);
	
	int ofImageMode;
	
	switch(bytesPerPixel) {
		case 1:
			ofImageMode = OF_IMAGE_GRAYSCALE;
			break;
		case 3: 
			ofImageMode = OF_IMAGE_COLOR;
			break;
		case 4: 
		default:
			ofImageMode = OF_IMAGE_COLOR_ALPHA; break;
	}
			
	ofLog(OF_LOG_VERBOSE, "about to setFromPixels");
	outImage.setFromPixels(pixels, width, height, ofImageMode, true);

	free(pixels);
	
	return true;
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
}

//--------------------------------------------------------------

string ofxNSStringToString(NSString * s)
{
	char newChars[ [s length]+1 ];
	
	[s getCString:newChars];
	
	return string(newChars);
}

//--------------------------------------------------------------

NSString * ofxStringToNSString(string s)
{
	return [[[NSString alloc] initWithCString: s.c_str()] autorelease];
}

<<<<<<< HEAD
=======
//--------------------------------------------------------------

string ofxiPhoneGetDocumentsDirectory()
{
	NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
	return ofxNSStringToString([paths objectAtIndex:0]) + "/";
}

>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d

/******************** ofxiPhoneScreenGrab *********************/

@interface SaveDelegate : NSObject {
	id delegate;
}
@property (retain, nonatomic) id delegate;
@end


@implementation SaveDelegate
@synthesize delegate;

// callback for UIImageWriteToSavedPhotosAlbum
- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo {
	ofLog(OF_LOG_VERBOSE, "Save finished");
	[image release];		// release image
	if( [delegate respondsToSelector: @selector(saveComplete)]) [delegate performSelector:@selector(saveComplete)];
	
	[self release];
}

-(void)dealloc {
	[delegate release];
	[super dealloc];
}

@end



// callback for CGDataProviderCreateWithData
void releaseData(void *info, const void *data, size_t dataSize) {
	//	NSLog(@"releaseData\n");
	free((void*)data);		// free the 
}


<<<<<<< HEAD
void iPhoneScreenGrab(id delegate) {
=======
void ofxiPhoneScreenGrab(id delegate) {
>>>>>>> cb96fc8aa36137c410bd42b133773ab95a47167d
	CGRect rect = [[UIScreen mainScreen] bounds];
	int width = rect.size.width;
	int height =  rect.size.height;
	
	NSInteger myDataLength = width * height * 4;
	GLubyte *buffer = (GLubyte *) malloc(myDataLength);
	GLubyte *bufferFlipped = (GLubyte *) malloc(myDataLength);
	glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
	for(int y = 0; y <height; y++) {
		for(int x = 0; x <width * 4; x++) {
			bufferFlipped[int((height - 1 - y) * width * 4 + x)] = buffer[int(y * 4 * width + x)];
		}
	}
	free(buffer);	// free original buffer
	
	CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, bufferFlipped, myDataLength, releaseData);
	CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();
	CGImageRef imageRef = CGImageCreate(width, height, 8, 32, 4 * width, colorSpaceRef, kCGBitmapByteOrderDefault, provider, NULL, NO, kCGRenderingIntentDefault);		
	
	CGColorSpaceRelease(colorSpaceRef);
	CGDataProviderRelease(provider);
	
	UIImage *image = [[UIImage alloc] initWithCGImage:imageRef];
	CGImageRelease(imageRef);
	
	SaveDelegate *saveDelegate = [SaveDelegate new];
	saveDelegate.delegate = delegate;
	UIImageWriteToSavedPhotosAlbum(image, saveDelegate, @selector(image:didFinishSavingWithError:contextInfo:), nil);
}


